# 第二章 数据的表示和运算

## 目录
- [第二章 数据的表示和运算](#第二章-数据的表示和运算)
  - [目录](#目录)
    - [2.1 数制与编码](#21-数制与编码)
      - [2.1.1 进位计数制及其相互转换](#211-进位计数制及其相互转换)
      - [2.1.2 定点数的编码表示](#212-定点数的编码表示)
      - [2.1.3 整数的表示](#213-整数的表示)
      - [2.1.4 C语言整数类型及类型转换](#214-c语言整数类型及类型转换)
    - [考点\&易错点](#考点易错点)
  - [2.2 运算方法和运算电路](#22-运算方法和运算电路)
    - [2.2.1 基本运算部件](#221-基本运算部件)
      - [一位全加器](#一位全加器)
      - [串行进位加法器](#串行进位加法器)
      - [并行进位加法器](#并行进位加法器)
      - [带标志加法器](#带标志加法器)
      - [算数逻辑单元ALU](#算数逻辑单元alu)
    - [2.2 定点数的移位运算](#22-定点数的移位运算)
      - [逻辑移位](#逻辑移位)
      - [算术移位](#算术移位)
    - [2.2.3 定点数加减运算](#223-定点数加减运算)
      - [补码加减法运算](#补码加减法运算)
      - [溢出判别方法](#溢出判别方法)
      - [加减运算电路](#加减运算电路)
      - [原码加减法运算](#原码加减法运算)
    - [2.2.4 定点数的乘除运算](#224-定点数的乘除运算)
      - [定点乘法](#定点乘法)
      - [除法运算](#除法运算)
    - [考点\&易错点整理（记得加强一下多算俩题）](#考点易错点整理记得加强一下多算俩题)
    - [C语言类型转换（自己做点练习）](#c语言类型转换自己做点练习)
  - [2.3 浮点数的表示与运算](#23-浮点数的表示与运算)
    - [2.3.1 浮点数的表示](#231-浮点数的表示)
      - [浮点数的表示格式](#浮点数的表示格式)
      - [浮点数表示范围](#浮点数表示范围)
      - [浮点数规格化](#浮点数规格化)
      - [IEEE754标准](#ieee754标准)
      - [定点、浮点表示的区别（考：浮点溢出判断）](#定点浮点表示的区别考浮点溢出判断)
    - [2.3.2 浮点数加减运算](#232-浮点数加减运算)
    - [2.3.3 C语言中浮点数类型](#233-c语言中浮点数类型)
    - [2.3.4 数据大小端\&对齐存储](#234-数据大小端对齐存储)
      - [大小端](#大小端)
      - [数据按边界对齐方式存储](#数据按边界对齐方式存储)

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换
- 计算机内部所有信息都是二进制编码的，原因
  - 制造简单，成本低
  - 逻辑判断简单
  - 编码、运算规则简单

1. 进位计数制
2. 进制转换
   - 2 -> 8、16
     - 整数高位补0，小数低位补0
   - 10 -> 2、8、16
     - 整数除以进制取余，先余出来的为低位
     - 小数乘以进制取整，先整出来的为高位

#### 2.1.2 定点数的编码表示
1. 真值和机器数
2. 机器数的定点表示
   - 现代计算机中
     - 补码整数表示整数
     - 原码小数表示浮点数的尾数部分
     - 移码表示浮点数的阶码部分
   - 定点小数
     - 纯小数
     - **约定小数点位置在符号位之后，有效数值部分最高位之前**
     - X = x0x1...xn
       - 其中 x0 为符号位，x1...xn 为有效数值部分（尾数）
       - x1 为最高有效位
   - 定点整数
     - 纯整数
     - **约定小数点位置在有效数值部分最低位之后**
     - X = x0x1...xn
       - 其中 x0 为符号位，x1...xn 为有效数值部分（尾数）
       - xn 为最低有效位
3. 原码、补码、反码、移码（定点数的编码表示法）
   - 原码
     - 最高位表示数的符号
     - 其余位表示数的绝对值
     - 字长为n+1时，表示范围 -(2^n-1) ~ 2^n-1（关于原点对称）
       - 0的原码表示方式有两种
     - 优点
       - 与真值转换简单
       - 实现乘除简便
     - 缺点
       - 0表示不唯一
       - 实现加减复杂
   - 补码
     - 正数补码和原码相同
     - 负数补码为模与该负数绝对值之差
     - 字长n+1时，表示范围 -(2^n) ~ 2^n-1（关于原点不对称）
       - 0的补码表示方式唯一
     - 真值 -> 补码
       - 正数一样
       - 负数：取原码，符号位不变，其余位取反后加1
     - 补码 -> 真值
       - 正数一样
       - 负数：取补码，符号位不变，其余位取反后加1
     - 变形补码：
       - 双符号位的补码表示（模4补码）
       - 左符号位表示真正的符号位
       - 右符号位判断溢出
   - 反码
   - 移码（只能表示整数）
     - 真值X上加一个常数（偏置值），字长n+1时，偏置值通常为2^n-1
     - 常用于浮点数的阶码部分
     - 特点：
       - 移码中零的表示唯一
       - 真值的移码和补码仅差一个符号位，[x]_补 的符号位取反即得到 [x]_移
       - 移码全0时，真值为最小值，-2^n
       - 移码全1时，真值为最大值，2^n-1
       - 保持数据原有大小顺序
- 4种编码总结如下
  - 原码、补码、反码符号位相同，正数的机器码相同
  - 原码、反码的表示在数轴上对称，0都有两种表示
  - 补码、移码在数轴上不对称，0表示唯一，比原码、反码多表示一个数
  - 原码容易判断大小，负数的补码、反码难以直接判断
    - 对于负数，数值位部分越小，其绝对值越大，即负得越多

#### 2.1.3 整数的表示
1. 无符号整数的表示
   - 全部二进制为全为数值位，没有符号位（默认数的符号为正）
2. 有符号整数的表示
   - 符号数值化，放在有效数字前面，前面四种码都可以表示，但补码有明显优势
     - 与原码、反码相比，0的补码表示方式唯一
     - 与原码、移码相比，运算规则简单，符号可以和数值位一起参与预算
     - 与原码、反码相比，多表示一个最小负数

#### 2.1.4 C语言整数类型及类型转换
1. C语言种整型数据类型
   - short、int、long（都为补码形式存储）
   - 加上unsigned，变为无符号类型
   - char（按无符号整数解释）
2. 有符号数和无符号数的转换
   - 强制类型转换的结果：保持二进制各位位值不变，仅改变解释方式
3. 不同字长整数之间转换
   - 大字长 -> 小字长
     - 高位截断、低位直接赋值
   - 小字长 -> 大字长
     - 有符号整数使用**符号扩展**
     - 无符号整数使用**零扩展**

### 考点&易错点
- 定点小数：
  - |符号位|（小数点位置）|有效数值部分|
  - 补码表示中：
    - 正数则符号位为0，有效数值部分与原码相同
    - 负数则符号位为1，有效数值部分为原码的反码加1

## 2.2 运算方法和运算电路

### 2.2.1 基本运算部件
- 计算机中，**运算器**由算数逻辑单元（ALU）、移位器、状态寄存器、通用寄存器组等组成
- 运算器基本功能
  - 加减乘除四则运算
  - 与或非异或等逻辑运算
  - 移位、求补等操作
- ALU的核心部件是**加法器**

#### 一位全加器
- **全加器（FA）**是最基本的加法单元
- 输入
  - 加数Ai，加数Bi，低位进位Ci-1
- 输出
  - 本位和Si，进位Ci
- 逻辑表达式
  - Si = Ai ⊕ Bi ⊕ Ci-1
  - Ci = AiBi + (Ai ⊕ Bi)Ci-1

#### 串行进位加法器
n个全加器相连得到n位加法器，称为**串行进位加法器**
- A = AnAn-1...A0
- B = BnBn-1...B0
- S = SnSn-1...S0
- C = Cn

#### 并行进位加法器
- 并行产生进位（先行进位），可以加快进位产生的速度，进而提升加法运算产生结果的速度

#### 带标志加法器
- n位加法器的基础上实现一些逻辑电路，生成相应标志信息
  - 溢出标志，`OF = Cn ⊕ Cn-1`
  - 进位借位标志，`CF =  Cout ⊕ Cin`
    - 判断无符号数加减运算是否溢出
    - Cout为Cn（即最高位的进位），Cin为最低位进位
  - 符号标志，`SF = Fn-1`
    - 有符号数加减运算结果的正负性（就是符号位）
  - 零标志，`当且仅当 F = 0 时 ZF = 1`
    - 判断加减运算结果是否为0

#### 算数逻辑单元ALU
- ALU核心是**带标志加法器**，同时也能执行与或非等逻辑运算
  - 加减乘除最终都能归结为加法运算
- 输入
  - 两个n位操作数A、B
  - 进位Cin
  - s位操作控制端ALUop（发出控制信号）
    - 例如ALUop选择Add运算，ALU执行加法运算，输出A加B之和
    - s位决定操作的种类数，如s=3，ALU最多8种操作
    - 一般是控制MUX（多路选择器）完成的
- 输出
  - n位F（ALU运算结果）
  - ZF、OF、SF、CF等标志位
  - Cout

### 2.2 定点数的移位运算
*加法* 结合 *移位* 来实现 *乘除运算*

#### 逻辑移位
- 逻辑左移
  - 高位移出，低位补0
  - 对于无符号整数逻辑左移，*高位1移出则溢出*
- 逻辑右移
  - 低位移出，高位补0
#### 算术移位
- 算术左移
  - 高位移出，低位补0
  - *移出的高位不同于移后的符号位*，则溢出
- 算术右移
  - 低位移出，高位补符号位
  - 低位1移出，*丢失精度*

### 2.2.3 定点数加减运算

#### 补码加减法运算
- 公式如下（机器字长为n+1）
  - [A + B]补 = [A]补 + [B]补 (mod 2^(n+1))
  - [A - B]补 = [A]补 + [-B]补 (mod 2^(n+1))
- 补码运算的特点
  - 二进制规则运算，逢二进一
  - 加法则直接相加，减法则 被减数 与 减数的负数 补码相加
  - 符号位与数值位一起参与运算
  - 高位丢弃，保留n+1位
- 理解
  - 我们是要求 A + B 的真值
  - 采用补码的形式存储A和B
  - 于是我们推导出A+B真值的补码，并由此制定补码加减法的运算规则

#### 溢出判别方法
补码定点数加减运算判断溢出有三种方法：
1. 采用一位符号位
   - 思路：参加操作的两个数符号位相同，但结果符号位不同，则发生溢出
   - 设A符号为As，B符号为Bs，结果符号为Ss
     - 溢出逻辑表达式为 $V = AsBs\bar{S_s} + \bar{A_s}\bar{B_s}S_s$
     - V = 0无溢出，1有溢出
2. 双符号位
   - 双符号位也称模4补码
   - 思路：运算结果的两个符号位Ss1Ss2相同，则未溢出；不同则溢出，此时最高符号位代表真正符号
   - **两个符号位如何计算得到**：Ss1 = As ⊕ Bs，Ss2 = Ss ⊕ Cn
     - Ss1Ss2 = 00，正数无溢出
     - Ss1Ss2 = 01，正溢出
     - Ss1Ss2 = 10，负溢出
     - Ss1Ss2 = 11，负数无溢出
   - 溢出判断逻辑 V = Ss1 ⊕ Ss2 
3. 一位符号根据数值位进位情况判断溢出
   - 符号位（最高位）的进位Cn与最高数位（次高位）的进位Cn-1相同，说明无溢出
   - V = Cn ⊕ 的进位Cn-1，0无溢出、1有溢出

#### 加减运算电路
- 补码实现无符号数有符号数的加/减法（**解释为什么能使用同一个加法器实现**）
  - 一个数补码表示为Y，其负数的补码为$\bar{Y}+1$
  - 只需原加法器的Y输入端增加n个反向器实现各位取反的功能，加一个2选1MUX，使用控制端Sub控制
  - Sub=0时将Y输入加法器，Sub=1时$\bar{Y}$输入加法器，并将Sub作为进位低位送入加法器（正好实现末位+1）
- 考点：**机器码解释成有符号数无符号数，及表示范围等**
- 通过标志信息区分有符号整数运算结果和无符号整数运算结果
  - 零标志ZF
  - 溢出标志OF：
    - 判断**有符号数**是否溢出
    - 对无符号数运算无意义
  - 符号标志SF：
    - 表示结果的符号，即F的最高位
    - 对无符号数运算无意义
  - 进/借位标志CF：
    - 表示无符号数运算时进位/借位，判断是否溢出
    - CF = Sub ⊕ Cout
    - **对有符号数运算无意义**
- 无符号数大小的比较
  - 对于无符号数，ZF和CF才有意义，现在假设有两个无符号数A和B
  - A - B为例
    - A = B时，A - B = 011 - 011 = 000，ZF=1，CF=0
    - A > B时，A - B = 011 - 010 = 001，ZF=0，CF=0
    - A < B时，A - B = 010 - 011 = (1)010 - 011 = 111，ZF=0，CF=1
  - 即
      |ZF|CF|A与B关系|
      |--|--|--|
      |1 |0 |A = B|
      |0 |0 |A > B|
      |0 |1 |A < B|
- 有符号数大小的比较
  - 对于有符号数，ZF、SF、OF才有意义，现在假设有两个有符号数A和B（以补码表示）
  - [A]补 - [B]补为例
    - A = B时，[A]补 - [B]补 = [A]补 + [-B]补 = 010 - 010 = 011 + 101 = (1)000，ZF=1，SF=0，OF=0
      - **着重记一下OF的计算**
    - A > B时，[A]补 - [B]补 = [A]补 + [-B]补 = 010 - 001 = 010 + 111 = (1)001，ZF=0，SF=0，OF=0
    - A < B时，
      - [A]补 - [B]补 = [A]补 + [-B]补 = 100 - 011 = 100 + 101 = (1)001，ZF=0，SF=0，OF=1
      - [A]补 - [B]补 = [A]补 + [-B]补 = 000 - 001 = 000 + 111 = (0)111，ZF=0，SF=1，OF=0
  - 即
      |ZF|SF|OF|A与B关系|情况|
      |--|--|--|--|--|
      |1 |0 |0 |A = B|相等|
      |0 |0 |0 |A > B|A大的不溢出减法|
      |0 |1 |1 |A > B|正减负溢出|
      |0 |0 |1 |A < B|负减正溢出|
      |0 |1 |0 |A < B|A小的不溢出减法|
  - 也即
      |ZF|SF⊕OF|A与B关系|
      |--|--|--|
      |1 |必定为0 |A = B|
      |0 |0 |A > B|
      |0 |1 |A < B|


#### 原码加减法运算
- 加法规则：同号求和、异号求差
- 减法规则：减数符号取反，被减数与符号取反后的减数按原码加法运算

### 2.2.4 定点数的乘除运算

#### 定点乘法
- 乘法运算基本原理
  - 原码乘法
    - 乘积符号由两个乘数符号位异或
    - 乘积数值位时两个乘数绝对值之积
  - 两个定点数的数值部分之积可视为两个无符号数乘积
  - 原码乘法运算
    - 被乘数和乘数均取绝对值参加运算，视为无符号数，符号位 xs ⊕ ys
    - 部分积Pi是乘法运算的中间结果，P0 = 0，从乘数最低位yn开始，前面所得部分积Pi加上X*yn-i，然后右移一位
      - 即Pi+1 = 2^-1(Pi + X * yn-i) (i = 0,1,...,n-1)
      - 最终得到 Pn = X * Y
- 乘法运算电路
  - 部分积和被乘数X做无符号加法时，可能产生进位，因此设置专门进位位C
  - 乘积寄存器P（初值置0）、乘积寄存器Y
  - 循环控制器Cn（初值置32），每次循环Cn减1
  - ALU为核心部件，对乘积寄存器P和被乘数寄存器X的内容做无符号加法运算
    - 结果送回乘积寄存器P，进位存放在C中
  - 每次循环 C -> P -> Y实现同步“逻辑右移”，即C存入P最高位，Y最低位移出
  - 从Y移出的最低位都送到控制逻辑，决定被乘数是否加到部分积上
- 无符号数和有符号乘法指令的移出判断
  - 字长32的计算机中，int型x、y（**有符号数**）
    - 高32位每一位都相同，且都等于乘积低32位符号，则不溢出
    - 否则溢出
  - unsigned int型x、y（**无符号数**）
    - 高32位每一位都为0，则不溢出
    - 否则溢出
- 阵列乘法器
  - 硬件叠加方式实现的快速乘法器，所有部分积同时产生并组成一个阵列
  - 多操作数相加，得到最终积
  - 最快可在一个时钟周期完成一条乘运算指令

#### 除法运算
- 基本原理
  - n位定点数的除法运算，统一为：2n位的数除以一个n位的数，得到n位的商
  - **定点正小数（原码小数）**
    - 被除数**低位**添n个0
  - **定点正整数（无符号数）**
    - 被除数**高位**添n个0
    - 整数除法时，若**除数**为0，发生除数为0异常，请求OS相应异常处理程序
  - 除法运算过程如下
    - 被除数与除数相剪，够减则上商为1，不够则上商为0
    - 重复，直到商的位数满足要求
  - 若2n位除以n位无符号数，商的位数为n+1位
    - 当第一次试商（**算商的第一位**）为1时，说明结果溢出（即无法用n位表示商）
  - 若两个n位无符号数相除，第一位商为0，结果肯定不会溢出
  - 若浮点数尾数原码小数相除，第一次试商为1，说明尾数部分有溢出，可通过右规消除
- 除法运算电路
  - 寄存器Y存放除数
  - 寄存器R
    - 初始存放被除数高32位
    - 过程中存放中间余数高位部分
    - 结束时存放余数
  - 寄存器Q
    - 初始存放扩展被除数低32位
    - 过程中 部分存放中间余数低位部分，部分存放商
    - 结束时存放32位商
  - ALU是核心部件，对R、Y做加减运算，结果送回寄存器R
  - 计数器Cn（初值置32），每次循环Cn减1
    - R -> Q同步左移，Q最高位移入R最低位，Q中空出的最低为被上商
    - 从低位开始逐次把商各位左移至Q
  - 每次控制逻辑根据ALU运算结果的符号决定上商是0还是1（够不够减）
- 两个32位int相除：仅-2^31 / -1 溢出，其他都不会

### 考点&易错点整理（记得加强一下多算俩题）
- 补码整数，提到右移基本是算术右移（如果说明是逻辑右移那就逻辑）

- 考运算发生溢出的时候，直接得出真值进行计算，然后看是否在表示范围内
  - 例如：8位补码，-128 ~ 127
    - 计算结果为128，溢出
    - 计算结果为-129，溢出
    - 计算结果为127，未溢出
    - 计算结果为-128，未溢出

- 双符号位补码（模4补码）溢出判别
  - Ss1 = As ⊕ Bs
  - Ss2 = Ss ⊕ Cn
  - Ss1Ss2 = 00，正数无溢出
  - Ss1Ss2 = 01，正溢出
  - Ss1Ss2 = 10，负溢出
  - Ss1Ss2 = 11，负数无溢出
  - 高位符号位决定正负
  - 低位符号位 异或 高位符号位，决定是否溢出

- 各种运算溢出的条件
  - 加法：符号位相同，结果符号位不同
  - 减法：符号位不同，结果符号位与被减数符号位相同
  - 乘法：高位符号位与低位符号位相同，结果符号位与高位符号位不同
  - 除法：第一次试商为1，说明溢出

- 多手写计算一下补码的计算方法

### C语言类型转换（自己做点练习）
- 隐式类型转换（自动类型转换）
  - 进行隐式转换的情况
    - 算数运算式中，低类型转换为高类型
      - 补充：有符号 -> 无符号
    - 赋值表达式中，右边表达式自动转换为左边类型（float -> int）
  - 低精度到高精度
    - int -> float
    - float -> double
  - 整形提升
    - 表达式计算中，各种整形首先需要提升为int类型，int不足时提升为unsigned int。提升完成后进行计算
      - char、short、unsigned short -> int
      - char、short、unsigned short -> unsigned int
  - 数据范围扩展
    - **对于表达式而言**
    - 一个表达式中包含不同类型的数据，较小范围的类型会自动转换成较大范围的数据
    - 例如：int + float -> float
  - 优先级
    - char -> short -> int -> unsigned int -> long -> unsigned long -> float -> double -> long double
- 强制类型转换（程序员手动指定）
  - （**整数之间**）强制类型转换的结果是保持二进制各位位值不变，**仅改变解释这些位的方式**
  - 可能会导致数据丢失
- **不同字长整数之间转换**
  - 大字长 -> 小字长
    - 高位截断，低位直接赋值
  - 小字长 -> 大字长
    - 有符号整数使用**符号扩展**
      - 符号位向高位扩展
    - 无符号整数使用**零扩展**
      - 高位补0
- **特点**
  - 隐式转换通常提升数据精度，强制转换可能降低精度
  - 目标类型范围小于源类型，可能会导致溢出或者数据截断
  - 混合类型运算中，自动隐式转换
- 例1
  - 源代码
    ```c
    // 4Byte int，那么16进制需要使用8位表示
    int x = 165537, u = -34991; // x = 0x000286a1. u = 0xffff7751
    short y = (short)x, v = (short)u;
    // y = 0x86a1, v = 0x7751
    printf("%d %d %d %d\n", x, y, u, v);
    ```
  - 输出
    ```
    165537 -31071 -34991 -30545
    ```

## 2.3 浮点数的表示与运算

### 2.3.1 浮点数的表示

#### 浮点数的表示格式
- N = (-1)^s * M * R^E
  - s：符号位
  - M：尾数（二进制定点小数，定点原码小数表示）
  - R：基数（隐含，约定为2、4、16等，表示阶码变化1时小数点移动多少位）
  - E：阶码（二进制定点整数，移码表示）
- 32位短浮点数格式例子：
  - |符号1位|阶码7位（偏置值为64）|尾数24位|
    - 阶码的值反映浮点数小数点实际位值
    - 阶码位数反映浮点数表示范围
    - 尾数的位数反映浮点数精度

#### 浮点数表示范围
- 上溢，**必须中断操作**，进行溢出处理
  - 正上溢——大于最大正数
  - 负上溢——小于 绝对值最大的负数
- 下溢（当作机器0处理）
  - 正下溢——0~最小正数
  - 负下溢——0~绝对值最小负数

#### 浮点数规格化
- 规格化操作，调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在最高数位上保持是一个有效值（非0）
- 左归
  - 运算结果尾数最高数位不是有效位，即0.000x...x的形式
  - 尾数每左移一位、阶码减1（基数为2时）
- 右归
  - 只需进行一次
  - 尾数右移一位、阶码加1（基数为2时）
  - **阶码增加可能导致溢出**

#### IEEE754标准
- 基数均为2
- 格式
  |类型|符号s|阶码e|尾数f|总位数|偏置值|
  |--|--|--|--|--|--|
  |单精度|1|8|23|32|7FH（127）|
  |双精度|1|11|52|64|3FFH（1023）|
- 尾数最高位总是1，为了使尾数多一位有效位，将其隐藏 -> 23位尾数实际上表示了24位有效数字，精度更高
- 指数使用移码表示，
  - 单精度偏置值为127，双精度偏置值为1023（不同于寻常n位偏置值，标准中为2^(n-1)-1）
- 真值
  - 单精度：(-1)^s * 1.f * 2^(e-127)
  - 双精度：(-1)^s * 1.f * 2^(e-1023)
- 表示范围  
  |格式|最小值|最大值|
  |--|--|--|
  |单精度|<p>e=1，f=0</p><p>1.0x2^(1-127)=2^-126</p>|<p>e=254，f=.111...；</p><p>1.111...x2^(254-127)=2^127x(2-2^-23)</p>|
  |双精度|<p>e=1，f=0</p><p>1.0x2^(1-1023)=2^-1022</p>|<p>e=2046，f=.111...；</p><p>1.111...x2^(2046-1023)=2^1023x(2-2^-52)</p>|
- 阶码全0/全1有特殊的解释
  - 全0阶码全0尾数：+0/-0，符号位决定正负，+0和-0是等效的
  - 全1阶码全0尾数：+∞/-∞，符号位决定正负（引入它的目的是计算过程中出现异常也能使程序继续下去）
  - 全1阶码非0尾数：NaN（Not a Number），无定义的数，*非数*
  - 全0阶码非0尾数：非规格化数
    - 阶码全0，尾数高位有1个或几个连续的0，但不全为0
    - **非规格化数的隐藏位为0**
    - 单精度双精度浮点数的指数分别别为-126和-1022
    - **可用于处理阶码下溢**
- 实数 -> IEEE754单精度浮点数
  - 实数->二进制数 -8.25 -> -1000.01 = -1.000 01x2^3
  - 符号位s=1
  - 计算阶码 E-127=3 -> E=130=1000 0010
  - 尾数23位，即000 0100 0000 0000 0000 0000
  - 最终结果
    - 1; 1000 0010; 000 0100 0000 0000 0000 0000 = C104 0000H

#### 定点、浮点表示的区别（考：浮点溢出判断）
- 数值表示范围
  - 字长相同时，浮点表示法能表示数值范围远大于定点表示法
- 精度
  - 浮点扩大范围但精度降低
- 数的运算
  - 浮点要做尾数运算、阶码运算，运算结果还要求规格化，更复杂
- 溢出问题
  - 定点中，结果超出数表示范围即溢出
  - 浮点中，结果超出尾数表示范围不一定溢出，**规格化后阶码超出能表示范围才发生溢出**

### 2.3.2 浮点数加减运算
- 对阶——阶码相同，小阶码向大阶码看齐（尾数右移时，移出的位不要丢掉，保留并参与尾数的运算
- 尾数加减——隐藏位1需要还原到尾数部分
- 尾数规格化——右规（**考虑舍入**），左规（可能多次）
- 舍入——移出的低位保留下来，最后考虑舍入，四种方法
  - 就近舍入
  - 正向舍入
  - 负向舍入
  - 截断法
- 溢出判断（**由指数上溢判断**）
  - 指数上溢（超过127或1023），**产生异常**
    - 右规和尾数舍入，阶码增大时判断是否指数上溢，全1时上溢
  - 指数下溢（小于-149或-1074），按机器0处理
    - 左归，全0时下溢
- 指定尾数/阶码采用补码表示时，**采用双符号位**
  - 尾数求和
    - 结果溢出（10.xxx...x或01.xxx...x），右规一次
    - 结果出现（00.0xx...x或11.1xx...x），左规直到变为（00.1xxx...x或11.0xxx...x）

### 2.3.3 C语言中浮点数类型
- 类型提升：char -> int -> long -> double; float -> double（转换过程**无损失**）
- int型和float型精度和范围分析
  - int -> float尾数大于24位时需舍入处理，影响精度
- int/float -> double
  - 不会影响精度（毕竟52位尾数）
- float/double -> int
  - 仅保留整数部分
  - 大数转换可能溢出

### 2.3.4 数据大小端&对齐存储

#### 大小端
- 大端方式
- 小端方式——低位存储于低字节（**存储单位是字节不是bit**）

#### 数据按边界对齐方式存储
- C中struct类型边界对齐要求
  - 每个成员按类型大小对齐
  - struct大小是成员最大对齐值的整数倍
- struct特点
  - 每个成员存储 `起始地址 % 对齐值 == 0`
  - 结构体长度是最大对齐值的整数倍  
  ```c
  struct A { // 8Byte
    int a;
    char b;
    short c;
  }

  struct B { // 12Byte
    char b;
    int a;
    short c;
  };
  ```