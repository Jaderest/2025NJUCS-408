# 第二章 数据的表示和运算

## 目录
- [第二章 数据的表示和运算](#第二章-数据的表示和运算)
  - [目录](#目录)
    - [2.1 数制与编码](#21-数制与编码)
      - [2.1.1 进位计数制及其相互转换](#211-进位计数制及其相互转换)
      - [2.1.2 定点数的编码表示](#212-定点数的编码表示)
      - [2.1.3 整数的表示](#213-整数的表示)
      - [2.1.4 C语言整数类型及类型转换](#214-c语言整数类型及类型转换)
    - [考点\&易错点](#考点易错点)
  - [2.2 运算方法和运算电路](#22-运算方法和运算电路)
    - [2.2.1 基本运算部件](#221-基本运算部件)
      - [一位全加器](#一位全加器)
      - [串行进位加法器](#串行进位加法器)
      - [并行进位加法器](#并行进位加法器)
      - [带标志加法器](#带标志加法器)
      - [算数逻辑单元ALU](#算数逻辑单元alu)
    - [2.2 定点数的移位运算](#22-定点数的移位运算)
      - [逻辑移位](#逻辑移位)
      - [算术移位](#算术移位)
    - [2.2.3 定点数加减运算](#223-定点数加减运算)
      - [补码加减法运算](#补码加减法运算)
      - [溢出判别方法](#溢出判别方法)
      - [加减运算电路](#加减运算电路)
      - [原码加减法运算](#原码加减法运算)
    - [2.2.4 定点数的乘除运算](#224-定点数的乘除运算)
      - [定点乘法](#定点乘法)
      - [除法运算](#除法运算)

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换
- 计算机内部所有信息都是二进制编码的，原因
  - 制造简单，成本低
  - 逻辑判断简单
  - 编码、运算规则简单

1. 进位计数制
2. 进制转换
   - 2 -> 8、16
     - 整数高位补0，小数低位补0
   - 10 -> 2、8、16
     - 整数除以进制取余，先余出来的为低位
     - 小数乘以进制取整，先整出来的为高位

#### 2.1.2 定点数的编码表示
1. 真值和机器数
2. 机器数的定点表示
   - 现代计算机中
     - 补码整数表示整数
     - 原码小数表示浮点数的尾数部分
     - 移码表示浮点数的阶码部分
   - 定点小数
     - 纯小数
     - **约定小数点位置在符号位之后，有效数值部分最高位之前**
     - X = x0x1...xn
       - 其中 x0 为符号位，x1...xn 为有效数值部分（尾数）
       - x1 为最高有效位
   - 定点整数
     - 纯整数
     - **约定小数点位置在有效数值部分最低位之后**
     - X = x0x1...xn
       - 其中 x0 为符号位，x1...xn 为有效数值部分（尾数）
       - xn 为最低有效位
3. 原码、补码、反码、移码（定点数的编码表示法）
   - 原码
     - 最高位表示数的符号
     - 其余位表示数的绝对值
     - 字长为n+1时，表示范围 -(2^n-1) ~ 2^n-1（关于原点对称）
       - 0的原码表示方式有两种
     - 优点
       - 与真值转换简单
       - 实现乘除简便
     - 缺点
       - 0表示不唯一
       - 实现加减复杂
   - 补码
     - 正数补码和原码相同
     - 负数补码为模与该负数绝对值之差
     - 字长n+1时，表示范围 -(2^n) ~ 2^n-1（关于原点不对称）
       - 0的补码表示方式唯一
     - 真值 -> 补码
       - 正数一样
       - 负数：取原码，符号位不变，其余位取反后加1
     - 补码 -> 真值
       - 正数一样
       - 负数：取补码，符号位不变，其余位取反后加1
     - 变形补码：
       - 双符号位的补码表示（模4补码）
       - 左符号位表示真正的符号位
       - 右符号位判断溢出
   - 反码
   - 移码（只能表示整数）
     - 真值X上加一个常数（偏置值），字长n+1时，偏置值通常为2^n-1
     - 常用于浮点数的阶码部分
     - 特点：
       - 移码中零的表示唯一
       - 真值的移码和补码仅差一个符号位，[x]_补 的符号位取反即得到 [x]_移
       - 移码全0时，真值为最小值，-2^n
       - 移码全1时，真值为最大值，2^n-1
       - 保持数据原有大小顺序
- 4种编码总结如下
  - 原码、补码、反码符号位相同，正数的机器码相同
  - 原码、反码的表示在数轴上对称，0都有两种表示
  - 补码、移码在数轴上不对称，0表示唯一，比原码、反码多表示一个数
  - 原码容易判断大小，负数的补码、反码难以直接判断
    - 对于负数，数值位部分越小，其绝对值越大，即负得越多

#### 2.1.3 整数的表示
1. 无符号整数的表示
   - 全部二进制为全为数值位，没有符号位（默认数的符号为正）
2. 有符号整数的表示
   - 符号数值化，放在有效数字前面，前面四种码都可以表示，但补码有明显优势
     - 与原码、反码相比，0的补码表示方式唯一
     - 与原码、移码相比，运算规则简单，符号可以和数值位一起参与预算
     - 与原码、反码相比，多表示一个最小负数

#### 2.1.4 C语言整数类型及类型转换
1. C语言种整型数据类型
   - short、int、long（都为补码形式存储）
   - 加上unsigned，变为无符号类型
   - char（按无符号整数解释）
2. 有符号数和无符号数的转换
   - 强制类型转换的结果：保持二进制各位位值不变，仅改变解释方式
3. 不同字长整数之间转换
   - 大字长 -> 小字长
     - 高位截断、低位直接赋值
   - 小字长 -> 大字长
     - 有符号整数使用**符号扩展**
     - 无符号整数使用**零扩展**

### 考点&易错点
- 定点小数：
  - |符号位|（小数点位置）|有效数值部分|
  - 补码表示中：
    - 正数则符号位为0，有效数值部分与原码相同
    - 负数则符号位为1，有效数值部分为原码的反码加1

## 2.2 运算方法和运算电路

### 2.2.1 基本运算部件
- 计算机中，**运算器**由算数逻辑单元（ALU）、移位器、状态寄存器、通用寄存器组等组成
- 运算器基本功能
  - 加减乘除四则运算
  - 与或非异或等逻辑运算
  - 移位、求补等操作
- ALU的核心部件是**加法器**

#### 一位全加器
- **全加器（FA）**是最基本的加法单元
- 输入
  - 加数Ai，加数Bi，低位进位Ci-1
- 输出
  - 本位和Si，进位Ci
- 逻辑表达式
  - Si = Ai ⊕ Bi ⊕ Ci-1
  - Ci = AiBi + (Ai ⊕ Bi)Ci-1

#### 串行进位加法器
n个全加器相连得到n位加法器，称为**串行进位加法器**
- A = AnAn-1...A0
- B = BnBn-1...B0
- S = SnSn-1...S0
- C = Cn

#### 并行进位加法器
- 并行产生进位（先行进位），可以加快进位产生的速度，进而提升加法运算产生结果的速度

#### 带标志加法器
- n位加法器的基础上实现一些逻辑电路，生成相应标志信息
  - 溢出标志，`OF = Cn ⊕ Cn-1`
  - 进位借位标志，`CF =  Cout ⊕ Cin`
    - 判断无符号数加减运算是否溢出
    - Cout为Cn（即最高位的进位），Cin为最低位进位
  - 符号标志，`SF = Fn-1`
    - 有符号数加减运算结果的正负性（就是符号位）
  - 零标志，`当且仅当 F = 0 时 ZF = 1`
    - 判断加减运算结果是否为0

#### 算数逻辑单元ALU
- ALU核心是**带标志加法器**，同时也能执行与或非等逻辑运算
  - 加减乘除最终都能归结为加法运算
- 输入
  - 两个n位操作数A、B
  - 进位Cin
  - s位操作控制端ALUop（发出控制信号）
    - 例如ALUop选择Add运算，ALU执行加法运算，输出A加B之和
    - s位决定操作的种类数，如s=3，ALU最多8种操作
    - 一般是控制MUX（多路选择器）完成的
- 输出
  - n位F（ALU运算结果）
  - ZF、OF、SF、CF等标志位
  - Cout

### 2.2 定点数的移位运算
*加法* 结合 *移位* 来实现 *乘除运算*

#### 逻辑移位
- 逻辑左移
  - 高位移出，低位补0
  - 对于无符号整数逻辑左移，*高位1移出则溢出*
- 逻辑右移
  - 低位移出，高位补0
#### 算术移位
- 算术左移
  - 高位移出，低位补0
  - *移出的高位不同于移后的符号位*，则溢出
- 算术右移
  - 低位移出，高位补符号位
  - 低位1移出，*丢失精度*

### 2.2.3 定点数加减运算

#### 补码加减法运算
- 公式如下（机器字长为n+1）
  - [A + B]补 = [A]补 + [B]补 (mod 2^(n+1))
  - [A - B]补 = [A]补 + [-B]补 (mod 2^(n+1))
- 补码运算的特点
  - 二进制规则运算，逢二进一
  - 加法则直接相加，减法则 被减数 与 减数的负数 补码相加
  - 符号位与数值位一起参与运算
  - 高位丢弃，保留n+1位
- 理解
  - 我们是要求 A + B 的真值
  - 采用补码的形式存储A和B
  - 于是我们推导出A+B真值的补码，并由此制定补码加减法的运算规则

#### 溢出判别方法
补码定点数加减运算判断溢出有三种方法：
1. 采用一位符号位
   - 思路：参加操作的两个数符号位相同，但结果符号位不同，则发生溢出
   - 设A符号为As，B符号为Bs，结果符号为Ss
     - 溢出逻辑表达式为 $V = AsBs\bar{S_s} + \bar{A_s}\bar{B_s}S_s$
     - V = 0无溢出，1有溢出
2. 双符号位
   - 双符号位也称模4补码
   - 思路：运算结果的两个符号位Ss1Ss2相同，则未溢出；不同则溢出，此时最高符号位代表真正符号
     - Ss1Ss2 = 00，正数无溢出
     - Ss1Ss2 = 01，正溢出
     - Ss1Ss2 = 10，负溢出
     - Ss1Ss2 = 11，负数无溢出
   - 溢出判断逻辑 V = Ss1 ⊕ Ss2 
3. 一位符号根据数值位进位情况判断溢出
   - 符号位（最高位）的进位Cn与最高数位（次高位）的进位Cn-1相同，说明无溢出
   - V = Cn ⊕ 的进位Cn-1，0无溢出、1有溢出

#### 加减运算电路
- 补码实现无符号数有符号数的加/减法（**解释为什么能使用同一个加法器实现**）
  - 一个数补码表示为Y，其负数的补码为$\bar{Y}+1$
  - 只需原加法器的Y输入端增加n个反向器实现各位取反的功能，加一个2选1MUX，使用控制端Sub控制
  - Sub=0时将Y输入加法器，Sub=1时$\bar{Y}$输入加法器，并将Sub作为进位低位送入加法器（正好实现末位+1）
- 考点：**机器码解释成有符号数无符号数，及表示范围等**
- 通过标志信息区分有符号整数运算结果和无符号整数运算结果
  - 零标志ZF
  - 溢出标志OF：
    - 判断**有符号数**是否溢出
    - 对无符号数运算无意义
  - 符号标志SF：
    - 表示结果的符号，即F的最高位
    - 对无符号数运算无意义
  - 进/借位标志CF：
    - 表示无符号数运算时进位/借位，判断是否溢出
    - CF = Sub ⊕ Cout
    - **对有符号数运算无意义**
- 无符号数大小的比较
  - 对于无符号数，ZF和CF才有意义，现在假设有两个无符号数A和B
  - A - B为例
    - A = B时，A - B = 011 - 011 = 000，ZF=1，CF=0
    - A > B时，A - B = 011 - 010 = 001，ZF=0，CF=0
    - A < B时，A - B = 010 - 011 = (1)010 - 011 = 111，ZF=0，CF=1
  - 即
      |ZF|CF|A与B关系|
      |--|--|--|
      |1 |0 |A = B|
      |0 |0 |A > B|
      |0 |1 |A < B|
- 有符号数大小的比较
  - 对于有符号数，ZF、SF、OF才有意义，现在假设有两个有符号数A和B（以补码表示）
  - [A]补 - [B]补为例
    - A = B时，[A]补 - [B]补 = [A]补 + [-B]补 = 010 - 010 = 011 + 101 = (1)000，ZF=1，SF=0，OF=0
      - **着重记一下OF的计算**
    - A > B时，[A]补 - [B]补 = [A]补 + [-B]补 = 010 - 001 = 010 + 111 = (1)001，ZF=0，SF=0，OF=0
    - A < B时，
      - [A]补 - [B]补 = [A]补 + [-B]补 = 100 - 011 = 100 + 101 = (1)001，ZF=0，SF=0，OF=1
      - [A]补 - [B]补 = [A]补 + [-B]补 = 000 - 001 = 000 + 111 = (0)111，ZF=0，SF=1，OF=0
  - 即
      |ZF|SF|OF|A与B关系|情况|
      |--|--|--|--|--|
      |1 |0 |0 |A = B|相等|
      |0 |0 |0 |A > B|A大的不溢出减法|
      |0 |1 |1 |A > B|正减负溢出|
      |0 |0 |1 |A < B|负减正溢出|
      |0 |1 |0 |A < B|A小的不溢出减法|
  - 也即
      |ZF|SF⊕OF|A与B关系|
      |--|--|--|
      |1 |必定为0 |A = B|
      |0 |0 |A > B|
      |0 |1 |A < B|


#### 原码加减法运算
- 加法规则：同号求和、异号求差
- 减法规则：减数符号取反，被减数与符号取反后的减数按原码加法运算

### 2.2.4 定点数的乘除运算

#### 定点乘法
- 乘法运算基本原理
  - 原码乘法
    - 乘积符号由两个乘数符号位异或
    - 乘积数值位时两个乘数绝对值之积
  - 两个定点数的数值部分之积可视为两个无符号数乘积
  - 原码乘法运算
    - 被乘数和乘数均取绝对值参加运算，视为无符号数，符号位 xs ⊕ ys
    - 部分积Pi是乘法运算的中间结果，P0 = 0，从乘数最低位yn开始，前面所得部分积Pi加上X*yn-i，然后右移一位
      - 即Pi+1 = 2^-1(Pi + X * yn-i) (i = 0,1,...,n-1)
      - 最终得到 Pn = X * Y
- 乘法运算电路
  - 部分积和被乘数X做无符号加法时，可能产生进位，因此设置专门进位位C
  - 乘积寄存器P（初值置0）、乘积寄存器Y
  - 循环控制器Cn（初值置32），每次循环Cn减1
  - ALU为核心部件，对乘积寄存器P和被乘数寄存器X的内容做无符号加法运算
    - 结果送回乘积寄存器P，进位存放在C中
  - 每次循环 C -> P -> Y实现同步“逻辑右移”，即C存入P最高位，Y最低位移出
  - 从Y移出的最低位都送到控制逻辑，决定被乘数是否加到部分积上
- 无符号数和有符号乘法指令的移出判断
  - 字长32的计算机中，int型x、y（**有符号数**）
    - 高32位每一位都相同，且都等于乘积低32位符号，则不溢出
    - 否则溢出
  - unsigned int型x、y（**无符号数**）
    - 高32位每一位都为0，则不溢出
    - 否则溢出
- 阵列乘法器
  - 硬件叠加方式实现的快速乘法器，所有部分积同时产生并组成一个阵列
  - 多操作数相加，得到最终积
  - 最快可在一个时钟周期完成一条乘运算指令

#### 除法运算
- 基本原理
  - n位定点数的除法运算，统一为：2n位的数除以一个n位的数，得到n位的商
  - **定点正小数（原码小数）**
    - 被除数**低位**添n个0
  - **定点正整数（无符号数）**
    - 被除数**高位**添n个0
    - 整数除法时，若**除数**为0，发生除数为0异常，请求OS相应异常处理程序
  - 除法运算过程如下
    - 被除数与除数相剪，够减则上商为1，不够则上商为0
    - 重复，直到商的位数满足要求
  - 若2n位除以n位无符号数，商的位数为n+1位
    - 当第一次试商（**算商的第一位**）为1时，说明结果溢出（即无法用n位表示商）
  - 若两个n位无符号数相除，第一位商为0，结果肯定不会溢出
  - 若浮点数尾数原码小数相除，第一次试商为1，说明尾数部分有溢出，可通过右规消除
- 除法运算电路
  - 寄存器Y存放除数
  - 寄存器R
    - 初始存放被除数高32位
    - 过程中存放中间余数高位部分
    - 结束时存放余数
  - 寄存器Q
    - 初始存放扩展被除数低32位
    - 过程中 部分存放中间余数低位部分，部分存放商
    - 结束时存放32位商
  - ALU是核心部件，对R、Y做加减运算，结果送回寄存器R
  - 计数器Cn（初值置32），每次循环Cn减1
    - R -> Q同步左移，Q最高位移入R最低位，Q中空出的最低为被上商
    - 从低位开始逐次把商各位左移至Q
  - 每次控制逻辑根据ALU运算结果的符号决定上商是0还是1（够不够减）
- 两个32位int相除：仅-2^31 / -1 溢出，其他都不会