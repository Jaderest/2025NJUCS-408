# 第三章 内存管理

先抄框架，具体内容做完题再填充

## 目录
- [第三章 内存管理](#第三章-内存管理)
  - [目录](#目录)
  - [3.1 内存管理概念](#31-内存管理概念)
    - [3.1.1 内存管理的基本原理和要求](#311-内存管理的基本原理和要求)
      - [内存管理主要功能](#内存管理主要功能)
      - [基本原理](#基本原理)
    - [3.1.2 连续分配管理方式](#312-连续分配管理方式)
      - [连续分配方式](#连续分配方式)
      - [动态分区分配（仍为连续分配方式）](#动态分区分配仍为连续分配方式)
    - [非连续分配方式](#非连续分配方式)
      - [3.1.3 基本分页存储管理](#313-基本分页存储管理)
      - [3.1.4 基本分段存储管理](#314-基本分段存储管理)
      - [3.1.5 段页式存储管理](#315-段页式存储管理)
    - [考点\&易错点整理](#考点易错点整理)
  - [3.2 虚拟内存管理](#32-虚拟内存管理)
    - [3.2.1 虚拟内存基本概念](#321-虚拟内存基本概念)
      - [传统存储管理方式的特征](#传统存储管理方式的特征)
      - [局部性原理](#局部性原理)
      - [虚拟存储器的定义和特征](#虚拟存储器的定义和特征)
      - [虚拟内存技术的实现](#虚拟内存技术的实现)
    - [3.2.2 请求分页管理方式](#322-请求分页管理方式)
      - [页表机制](#页表机制)
      - [缺页中断机构](#缺页中断机构)
      - [地址变换机构](#地址变换机构)
    - [3.2.3 页框分配](#323-页框分配)
      - [驻留集大小](#驻留集大小)
      - [内存分配策略](#内存分配策略)
      - [物理块调入算法](#物理块调入算法)
      - [调入页面的时机](#调入页面的时机)
      - [何处调入页面](#何处调入页面)
    - [3.2.4 页面置换算法](#324-页面置换算法)
      - [最佳（OPT）置换算法](#最佳opt置换算法)
      - [FIFO页面置换算法（只有它会Belady）](#fifo页面置换算法只有它会belady)
      - [LRU页面置换算法](#lru页面置换算法)
      - [时钟页面置换算法](#时钟页面置换算法)
      - [3.2.5 抖动和工作集](#325-抖动和工作集)
      - [3.2.6 页框回收](#326-页框回收)
      - [3.2.7 内存映射文件](#327-内存映射文件)
      - [3.2.8 虚拟存储器性能影响因素](#328-虚拟存储器性能影响因素)
      - [3.2.9 地址翻译（看完计组再来？）](#329-地址翻译看完计组再来)

## 3.1 内存管理概念

### 3.1.1 内存管理的基本原理和要求

#### 内存管理主要功能
- **内存空间的分配和回收**：记录空闲空间、分配情况、回收空间
- **地址转换**：vaddr -> paddr
- **内存扩充**：虚拟存储技术从逻辑上扩充内存
- **内存共享**：多个进程共享同一块内存空间，需支持堆内存共享区域的受控访问
- **存储保护**：互不干扰

#### 基本原理
1. 逻辑地址和物理地址
2. 程序链接与装入
  - 三个工作阶段
    - 编译：源代码 -> 若干目标模块
    - 链接：一组目标模块 + 库函数 -> 完整的装入模块
    - 装入：装入模块 装入 物理内存
  - 装入方式
    - 绝对装入
      - 只适用于单道程序环境
      - 逻辑地址与实际内存地址完全相同
    - 可重定位装入（静态重定位）
      - 编译链接后装入模块始地址通常从0开始
      - 程序中指令和数据的地址都是相对始址的**逻辑地址**
      - **重定位**：**装入时**对目标程序中相对地址的修改过程（**由操作系统+装入程序**完成）
      - 地址转换在装入时一次完成，**完成后，修改得到的地址全都为物理地址**
    - 动态运行时装入（动态重定位）
      - 执行过程中进行
      - 允许程序在内存中移动
      - 每个进程在PCB中存储重定位寄存器的值，在进程切换时保存恢复
      - 动态重定位过程依赖于
        - 可重定位装入程序（在重定位的过程中执行）
        - 重定位寄存器（获取基地址）
        - 地址变换机构（相加得到物理地址）
      - 优点：程序可分配到不连续存储区；
  - 链接方式
    - 静态链接
      - 几个目标模块装配成一个完整的装入模块，需解决两个问题：
        - 修改相对地址
        - 外部调用符号也都变换为相对地址
    - 装入时动态链接
    - 运行时动态链接
3. 进程内存映像
  - 基本要素
    - 代码段
    - 数据段
    - PCB（Process Control Block，进程控制块）
    - 堆
    - 栈
4. 内存保护
  - 两种方法
    - CPU设置上、下限寄存器，存放用户进程在贮存中下限地址和上限地址
      - CPU访问一个地址时，与俩寄存器相比，判断有无越界
    - 重定位寄存器（基地址寄存器）+ 界地址寄存器（限长寄存器）
      - 重定位寄存器存放进程的起始地址——用来 vaddr 转换为 paddr
      - 界地址寄存器存放进程的**最大逻辑地址**——逻辑地址与它相比，大则越界，小再通过重定位寄存器转换为物理地址
      - 使用这俩寄存器必须使用特权指令
5. 内存共享
  - 可重入代码（纯代码）
6. 内存分配与回收

### 3.1.2 连续分配管理方式
*连续分配*方式：用户需要100MB内存空间，连续分配就在内存空间中位用户分配一块连续的100MB空间

 #### 连续分配方式
1. 单一连续分配
2. 固定分区分配（可有不同大小 但事先固定）
3. 动态分区分配

#### 动态分区分配（仍为连续分配方式）
1. 基本原理
2. 基于顺序搜索的分配算法
3. 基于索引搜索的分配算法

### 非连续分配方式
非连续分配方式，根据分区大小是否固定分为
- 分页存储管理（根据是否将作业所有页面都装入内存才能运行分为）
  - 基本分页存储管理
  - 请求分页存储管理
- 分段存储管理

#### 3.1.3 基本分页存储管理
- 物理内存中：4KB分区，称为*页框、页帧或物理块*
- 进程逻辑地址空间也分为与块大小相等的若干区域，称为*页或页面*
1. 分页存储基本概念
  - 页面和页面大小
    - 逻辑地址空间中每个页面有编号，称为*页号*
    - 内存空间中每个页框也有编号，称为*页框号*（物理块号）
    - 页面大小，2的整数次幂
  - 地址结构
    - 页号P 12~31位 （最多2^20个页面）
    - 页内偏移量W 0~11位 （页大小为2^12字节，即4KB）
  - 页表
    - 每个进程一个页面映射表（页表）
    - 页表项：由页号和块号组成
    - 作用：实现页号到物理块号的地址映射
2. 基本地址变换机构
  - 基本概念
    - 地址变换机构的任务：逻辑地址->内存中物理地址
    - *地址变换*借助于页表实现
    - 页表寄存器（Page Table Register，PTR）
      - 存放页表的在内存中起始地址和页表长度M
      - 进程未执行时，页表始址放在本进程PCB中；被调度执行时，页表始址和页表长度装入PTR
  - 页面大小L，逻辑地址A到物理地址E的变换
    - 页号P = A / L, 页内偏移量W = A % L
    - 判断页号越界
      - 如果P > M，页号越界，越界中断
      - 如果P <= M，页号合法
    - 页表寄存器：页表始址F，页表长度M
    - 页表项地址 = F + P * 页表项长度，根据地址取出页表项中物理块号b（页框号）
    - 物理地址E = b * L + W
3. 具有快表的地址变换机构
  - 快表（Translation Lookaside Buffer，TLB），相联存储器，不在内存中，是一个高速缓存
  - 有快表的地址变换过程如下：
    - CPU给出逻辑地址，硬件进行地址转换，页表与快表中所有页号进行比较
    - 若匹配上，直接从快表中取出该页对应物理块号b，与页内偏移量拼接形成物理地址，**一次访存**
    - 若未匹配上，访问内存中的页表，与基本地址变换机构相同，取出物理块号b，形成物理地址并访存，同时将页号P和物理块号b存入快表，**两次访存**
4. 两级页表
  - 每个进程页表项数可达2^20个，2^20 * 4B / 4KB = 1K个页，还要求连续，明显不现实
  - 两种解决办法：
    - 对于页表所需内存空间，采用离散分配方式，用一张索引表来记录各个页表的存放位置，解决了页表占用连续内存空间的问题
    - 只将需要的部分页表项调入内存，其余的页表项仍驻留磁盘，需要时再调入磁盘（虚拟内存的思想）
      - 实际上就是为离散分配的页表再建立一张页表，称为*外层页表*（或*页目录*）
      - 逻辑地址空间的格式：
        - 一级页号或页目录号10位
        - 二级页号或页表号10位
        - 页内偏移12位
  - **外层页表寄存器**（页目录基址寄存器）：存放页目录始址
    - 页目录号作为页目录索引，找到对应页表的始址
    - 再用*二级页号*作为页表分页索引，找到对应的页表项
    - 页表项的物理块号和页内偏移拼接形成物理地址
    - 使用该物理地址访存，共进行了**三次访存**

#### 3.1.4 基本分段存储管理
分页通过*硬件机制*实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，满足**方便编程**、**信息保护**和**共享**、**动态增长**及**动态链接**等多方面需要
1. 分段
  - 分段系统将用户进程的逻辑地址划分大小不等的*段*
    - 用户进程由主程序段、两个子程序段、栈段和数据段组成
    - 于是进程划分5段，每段从0开始编址，并分配一段连续的地址空间（段内连续，段间不连续）
    - 进程的地址空间是二维的
  - 分段存储管理的逻辑地址
    - 段号S 31~16位
    - 段内偏移量W 15~0位
    - 一个进程最多有2^16个段，最大段长64KB
  - 在分段系统中，段号和段内偏移量必须由用户显示提供，高级语言中由编译器完成
2. 段表
  - 每个段对应一个*段表项*
    ```
      |段号|段长|本段在主存的始址|
    ```
  - 段表项连续存放，各段表项长度相同，因此段号可以隐含（直接用段号作为索引）
  - 若段表存放始址为M，K号段存放的地址为 M + K * 6(6Byte = 16bit段内偏移量（可全部用来表示段长） + 32bit物理内存)
3. 地址变换机构
  - 段表寄存器（Segment Table Register，STR）：存放段表的起始地址F和段表长度M
  - 地址变换过程：
    1. 逻辑地址A中取出前几位为段号S，后几位为段内偏移量W
    2. 判断段号是否越界，S >= M，产生越界中断
    3. 段表查询段表项，段号S对应段表项地址 = F + S * 段表项长度
    4. 取出段表项中段长C，若W >= C，产生越界中断
    5. 取出该段始址b，物理地址E = b + W
4. 分页分段对比
  - 都是非连续分配方式，都需要地址映射机构实现地址变换
  - 概念上完全不同：
    1. 页是信息的物理单位，分页是提高内存利用率，完全是系统的行为，对用户不可见；段时信息的逻辑单位，为了更好地满足用户需求，用户按照逻辑关系将程序划分为若干段，分段对用户可见
    2. 页大小固定，由系统决定；段长不固定，取决于用户编写程序
    3. 分页管理地址空间是一维的；段管理，每段长度不固定，无法通过除法得出段号，所以分段管理的地址空间是二维的
5. 段共享与保护
  - 共享：
    - 段共享：为了共享，只需要为段设置一个段表项即可。共享段表，表项记录共享段的段号、段长、内存始址、状态（存在）位、外村始址、共享进程计数count等
    - 页共享：若被共享的代码占N个页框，则**每个**进程的页表中都要建立N个页表项，指向被共享的N个页框
  - 保护：
    - 段保护两种方法：
      1. 存取控制保护
      2. 地址越绝保护：段表寄存器中段表长度 与 逻辑地址中段号比较；段表项中段长 和 逻辑地址段内偏移比较
    - 分页：
      - 仅需判断页号是否越界，页内偏移不可能越界（位数固定）

#### 3.1.5 段页式存储管理
进程地址空间分为若干逻辑段，每段由自己段号，将各个段分成若干大小固定的页
- 进程逻辑地址分为三部分：
  ```
    |段号S|页号P|页内偏移量W|
  ```
- 每个进程一个段表
  - 段表项：段号（连续所以隐含）、页表长度，页表始地址
- 每个段一张页表（**所以每个进程可能有多个**）
  - 页表项：页号（连续所以隐含）、物理块号
- 系统维护段表寄存器，指出进程段表始址和段表长度
  - **段表寄存器和页表寄存器作用：1. 寻址 2. 判断是否越界**

### 考点&易错点整理

- 实现虚拟内存（逻辑地址也算一定程度上的虚拟内存）的管理需要**硬件和软件**的支持
  - 请求分页页表机制
  - 缺页中断机构
  - 地址变换机构

- 存储管理方式，需要硬件地址变换机构支持的
  - 页式存储管理
  - 动态分区分配
  - 页式虚拟存储管理
  - **注意单一连续分配和固定分区分配**：均采用静态重定位，直接

- 固定分区分配，每个分区大小
  - 可以不同，但**事先固定**
  - 少量大分区
  - 适量中分区
  - 多量小分区

- 动态重定位
  - 执行过程中进行
  - 允许程序在内存中移动
  - 每个进程在PCB中存储重定位寄存器的值，在进程切换时保存恢复
  - 动态重定位过程依赖于
    - 可重定位装入程序（在重定位的过程中执行，所以！这个程序装入后不会立即结束）
    - 重定位寄存器（获取基地址）
    - 地址变换机构（相加得到物理地址）

- 各个存储管理方案可使用的程序
  - 单一连续分配：绝对装入 （单用户单任务单程序）
  - 固定分区分配：静态、动态重定位 （作业装入内存后位置不会改变，所以静态、动态重定位都允许）
  - 动态分区分配：动态重定位
    - **分页管理不允许静态重定位**，静态重定位要求分配其需要的全部连续空间，而分页是离散的

- 内部碎片vs外部碎片
  - 内部碎片：分区大小大于程序所需要的大小
    - 固定分区分配、单一连续分配、分页管理（分页不产生外部碎片，全都对齐分掉了）
  - 外部碎片：空闲的小内存块，可通过紧凑技术管理
    - 动态分区分配、分段管理（分段不产生内部碎片，因为段大小不固定）
  - 段页式都会产生，但平均产生的都较小

- 采用分段/分页管理后，提供给用户的物理地址空间取决于
  - 总空间大小 - 页表/段表的长度
  - **需要额外的物理地址来存储这些数据结构**

- 存储管理的代价最小的是——分区存储管理
  - 实现分页、分段、段页式存储管理都需要特定数据结构支持，还需要硬件提供快存、地址加法器，代价高
  - **分区存储管理式满足多道程序设计的最简单的存储管理方案**，适合嵌入式等微型设备

- 对主存储器的访问，以字节为单位
  - 并不是分配那些
  - 访问的单位和编址单位应该是一样的

- 段页式存储管理，内存地址结构是**二维**的
  - 段页式存储管理的内存地址分为三部分：段号、页号、页内地址
  - 但是！分页是OS的行为，用户并**不用指出**页内偏移量的位数
  - 而分段之间是独立的，需要指出段号的位数
  - **确定一个地址需要几个参数，那么作业地址空间就是几维的**
    - 这里段号、段内偏移量由用户提供
    - 页号和页内地址都是由地址变换机构计算出来

- 区别页号和页框号
  - 页号：逻辑地址空间中的编号
  - 页框号：物理内存中的编号
  - 页表项即页号->页框号的映射关系，由此实现了离散分配内存

- 会对分区排序的基于顺序搜索的算法有
  - 最佳适应算法
  - 最差适应算法

- 最容易产生内存碎片的动态分区分配算法——最佳适应算法
  - 最佳适应算法几乎每次分配内存都会产生很小的难以利用的内存块
  - ？但是不会拆分区吗
    - 会拆分区，所以比需求稍大的内存块的话，拆开只剩下一个小内存块，它分配不出去，这就是碎片了

- CPU页表基址寄存器：存放顶级页表的起始地址
  - 多级页表中，存的就是当前进程的一级页表的起始物理地址

- 多级页表
  - 引入：页表项数目过多，无法连续存放
  - 优点：减少页表所占的连续内存空间（实际上就是离散分配页表）
  - 缺点：地址变换过程复杂，增加了内存访问时间（可能多次访存）


## 3.2 虚拟内存管理

### 3.2.1 虚拟内存基本概念

#### 传统存储管理方式的特征
3.1讨论的各种内存管理策略都是为了同时将多个进程保留在内存中，以便允许多道程序设计，具有以下两个共同的特征：
1. 一次性
  - 当作业很大而不能全部装入内存时，则该作业无法运行
  - 大量作业要运行的时候，只能少数作业先运行，导致多道程序**并发度**下降
2. 驻留性
  - 作业被装入内存后，一直驻留，任何部分都不会被换出，但是它可能长期阻塞

即浪费了内存空间，降低了并发度

#### 局部性原理
1. 时间局部性
  - 某条指令或数据被访问后，短时间内再次被访问的概率很大
  - 高速缓存
2. 空间局部性
  - 某条指令或数据被访问后，短时间内与它相邻的指令或数据被访问的概率很大
  - 较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现

虚拟内存技术实际上建立“内存-外存”的两级存储结构，利用局部性原理实现高速缓存

#### 虚拟存储器的定义和特征
- 程序装入时，仅将程序当前运行用到的少数页面装入内存，其余留在外存便可启动程序执行
- **请求调页**：当所访问的信息**不在**内存时，由OS负责将所需信息从外存调入内存，并继续执行
- **页面置换**：内存空间**不足**时，OS将暂时用不到的信息换出到外存，腾出空间存放将要调入内存的信息
- 系统好像为用户提供了一个比实际内存容量大得多的存储器，称为**虚拟存储器**

- 虚拟存储器分为以下三个主要特征：
  1. **多次性**：无须一次性全部装入，而是允许被多次调入内存。运行到尚未调用的部分时，才将它们调入（最重要特征）
  2. **对换性**：作业运行时无须一直常驻内存，允许将暂不使用的程序和数据从内存调至外存的对换区（**换出**），待需要时再调入内存（**换入**），由于这个性质才得以正常运行
  3. **虚拟性**：逻辑上扩充了内存的容量，远大于实际容量。（最重要特征，也是实现虚拟存储器的**最重要目标**）

#### 虚拟内存技术的实现
虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。

虚拟内存的实现由如下三种方式：
1. 请求分页存储管理
2. 请求分段存储管理
3. 请求段页式存储管理

硬件需要有如下支持：
1. 一定容量的内存外存
2. 页表机制（段表）机制，作为主要数据结构
3. 中断机构，要访问的部分未调入内存时，则产生中断
4. 地址变换机构，支持逻辑地址到物理地址的转换

### 3.2.2 请求分页管理方式
- 建立在基本分页系统的基础上，并增加了**请求调页**和**页面置换**功能
  - 请求调页：访问的页面不在内存时，通过请求调页将其从外存调入内存
  - 页面置换：内存空间不够时，通过页面置换功能将内存中暂时用不到的页面换出至外存

除了需要一定容量的内存和外存，还需要页表机制、缺页中断机构和地址变换机构

#### 页表机制
- 为实现**请求调页**功能，OS需要直到每个页面是否已调入内存，未调入则还需要知道该页在外存中存放地址。
- 为实现**页面置换**功能，OS需要某些指标来决定换出哪些页面，对于要换出的页面还需要知道是否被修改过，来决定是否写回外存。
- 请求页表项如下（添加了4个字段）
  ```
  页表项：|页号|物理块号|状态位P|访问字段A|修改位M|外存地址|
  ```
  - 状态位P：标记该页是否已调入内存
  - 访问字段A（访问位）：本页一段时间内访问次数/多长时间未被访问，供置换算法换出页面时参考
  - 修改位M：标记该页调入内存后是否修改过
  - 外存地址：通常是物理块号

#### 缺页中断机构
- 访问的页面不在内存时，便产生一个*缺页中断*，请求操作系统*缺页中断处理程序*处理：
  - 内存中有空闲页框则分配，将所缺页面从外存装入该页框，并修改页表中相应表项
  - 若内存中没有空闲页框，则*页面置换算法*选择一个页面淘汰，若该页被修改过则还要写回外存
- 缺页中断与一般中断相比，有以下两个明显区别
  - 指令执行期间产生中断，而非一条指令执行完后产生和处理，属于**内部异常**
  - 一条指令在执行期间，可能产生**多次**缺页中断

#### 地址变换机构
请求分页系统的地址变换过程如下：
1. 检索快表，命中则从相应表项取出该页物理块号，并修改页表项访问位。（写指令则将修改位M置为1）
2. 若快表未命中，则访问页表，取出页表项中的物理块号，并将其写入快表
  - 若快表已满则采用某种算法替换
3. 若在页表中未找到，缺页中断，请求系统将该页从外存换入内存，调入后，OS负责更新页表快表，并获得物理块号
4. *物理块号*与*页内地址* 拼接形成物理地址，用该地址访存


### 3.2.3 页框分配

#### 驻留集大小
给一个进程分配的页框的集合就是这个程序的**驻留集**，需要考虑以下两点
1. 驻留集越小，并发度越高，但缺页率较高，CPU花费大量时间处理缺页
2. 驻留集越大，在进程页框较多的时候，增加页框对缺页率的改善并不明显，反而浪费内存，同时多道程序并发度下降

#### 内存分配策略
请求分页式系统中
- 两种分配策略，**固定分配策略**和**可变分配策略**
- 两种置换策略，**全局置换**和**局部置换**

组合出三种（全局意味着进程拥有的物理块数量必然会变）适用的策略：
1. 固定分配局部置换
  - 进程物理块数量固定，运行期间都不改变
  - 局部置换：缺页时，只能从**该**进程的页面中选一页换出，保证进程内存空间不变
  - 难以确定应为每个进程分配多少物理块，少会频繁缺页中断，多会降低CPU、其他资源利用率
2. 可变分配全局置换
  - 先为每个进程分配一定数量物理块，运行期间适当增加减少
  - 全局置换：缺页时，从空闲物理队列中选一块分配
  - 更灵活，但有时会盲目给进程增加物理块，从而导致系统并发能力下降
3. 可变分配局部置换
  - 若进程频繁缺页，则系统再给它分配更多物理块
  - 若缺页率特别低，则适当减少但不能引起缺页率明显增加
  - 保证进程不会过多调页的同时也保持并发能力
  - 实现更复杂、开销更大，但比起频繁换入换出性能更好

#### 物理块调入算法
固定分配策略时如下：
1. 平均分配算法
2. 按比例分配算法：根据进程大小比例分配
3. 优先权分配算法
  - 物理块分成两个部分，一部分按比例分配给各个进程，一部分根据优先权分配

#### 调入页面的时机
两种策略
1. 预调页策略（运行前调入）：预测不久之后可能访问的页面，将它们预先调入内存，但预测成功率低，所以主要用于进程首次调入
2. 请求调页策略（运行期间调入）：发现哪些页不在内存则提出请求，请求的一定会访问
  - 易于实现，但是一次仅调入一页，增加了磁盘I/O开销

#### 何处调入页面
外存分为两部分：存放文件的*文件区*，存放对换页面的*对换区*（也称*交换区*）

分为三种情况：
1. 系统拥有足够的对换区空间
  - 全部从对换区调入所需页面
  - 进程运行前，需将与该进程有关的文件从 文件区 -> 对换区
2. 系统缺少足够的对换区空间
  - 可能被修改的部分将它们换出时必须放在对换区
  - 不会被修改的文件直接从文件区调入
3. UNIX方式
  - 进程有关的文件都放在文件区，未运行过的页面放在文件区，运行过但是换出的文件放在对换区，从相应区调入即可。
  - 进程层请求的共享页面若被其他进程调入，则不需要再次调入

### 3.2.4 页面置换算法
内存无空闲空间时，需要从内存中换出一页到外存，选择调出哪个页面的算法即*页面置换算法*
- 页面置换算法的目标是**减少缺页率**

有如下四种算法（最好自己手画一下置换图）：
#### 最佳（OPT）置换算法
- 淘汰*永不使用*的页面或是***最长时间内**不再被访问的页面*，保证获得最低的缺页率
- **无法实现**，但是可用于评估其他算法的性能
- 注意区别最长时间和被访问次数最小

#### FIFO页面置换算法（只有它会Belady）
- **Belady异常**：当为进程分配的物理块增多时，缺页次数不减反增

#### LRU页面置换算法
- LRU（Least Recently Used）算法：淘汰*最长时间未被访问*的页面
- 需要寄存器&栈的硬件支持，开销较大

#### 时钟页面置换算法

1. 简单CLOCK置换算法
  - 每个页面设置一个*访问位*
  - 访问一个页面时，*访问位*置为1
  - 内存中页面链接成一个循环队列，有一个替换指针与之关联（指谁就检查谁、替换谁）
  - 需要置换时（当且仅当需要置换时替换指针才会动）
    - 从替换指针开始，检查页面的访问位
    - 若访问位为1，则将其置为0，替换指针指向下一个页面
    - 若访问位为0，则将该页面换出，替换上的页面访问一般置1（因为马上用了），替换指针指向下一个页面
  - 循环检查所有页面，所以称为CLOCK算法
  - 置换时将为使用页面换出，也称NRU（Not Recently Used）算法
  - **画置换图的时候注意它的指针变化，若不缺页，替换指针是不动的**

2. 改进的CLOCK置换算法
  - 访问位A、修改位M
    - 1类页面：A = 0, M = 0，最近未访问且未被修改，是最佳的淘汰页
    - 2类页面：A = 0, M = 1，最近未访问但被修改，次佳的淘汰页（需要写回外存）
    - 3类页面：A = 1, M = 0，最近访问但未被修改，可能被再访问
    - 4类页面：A = 1, M = 1，最近访问且被修改，可能被再访问
  - 算法如下：
    1. 从指针当前位置开始，扫描循环队列，寻找1类页面，遇到的第一个1类页面淘汰 （本遍扫描不改变访问位）
    2. 若没有1类页面，则扫描寻找2类页面，遇到的第一个2类页面淘汰 （扫过的所有访问位A都置为0）
    3. 若2也失败，则指针返回到开始位置，并将**所有**帧的访问位复0，重复1）、2），此时一定能找到
  - 减少磁盘的I/O次数，但是算法本身开销可能大一点

#### 3.2.5 抖动和工作集
暂不考好像

#### 3.2.6 页框回收
主要还是页面缓冲算法的介绍

1. 页面缓冲算法
   - 页式虚拟存储管理中换入换出开销会对性能产生重大影响，影响页面换入/换出效率的因素包括：
     1. 页面置换算法
     2. 已修改页面写回磁盘的频率
     3. 磁盘内容读入内存频率
   - 于是页面缓冲算法在原页面置换算法的基础上，增设**已修改页面链表**
     - 保存已修改并且需要被换出的页面，就一起换出
     - 特点：
       - 显著降低页面换入/换出频率，大幅降低磁盘I/O开销
       - 当采用一种较为简单的置换策略（如FIFO）时，不需特殊硬件支持，实现特别简单
   - 设置如下两个链表
     - 空闲页面链表：进程需读入一个页面中，从该链表取链首的页框装入该页，
     - 修改页面链表：进程需要换出一个已修改页面时，系统不立即将它换出到磁盘
   - 上述将物理页面换出的过程即为页框的回收

2. 页框回收
   - 属于内核（内核栈、内核代码段和大部分内核使用的页框）的大部分页框都是不能回收的，进程使用的大部分是可以回收的
   - Linux内核中，守护进程kswapd：检查内存使用情况，页框数量少于阈值时，发起页框回收操作
     - 为什么达到阈值而不是满了就回收？
       - 要释放页框，可能要申请页框来作为I/O缓冲区来将数据写回磁盘，陷入内存请求僵局
   - Linux采用伙伴算法统计记录内存中空闲页框

#### 3.2.7 内存映射文件
- 内存映射文件（Memory-Mapped File）是OS向应用程序提供的**系统调用**，在磁盘文件与进程的虚拟地址空间之间建立映射关系
  - 进程使用系统调用，将文件映射到它虚拟地址空间某区域，能用访问内存的方式读/写文件（将文件当作内存中大字符数组来访问，更为方便）
  - 磁盘文件读写由OS完成，进程无感知
  - 映射进程的页面时，不会实际读入，**只有**在访问页面时才每次一页地读入，关闭映射文件时，才将**所有**被改动的页面写回磁盘文件
- **共享内存**很多时候时通过映射相同文件到通信进程的虚拟地址空间实现
  - 多个进程映射到同一文件时，各进程虚拟地址空间相互独立
  - 但是虚拟地址空间映射到相同的物理内存（页表实现）
- 内存映射文件的优点
  - 编程更简单，已建立映射的文件只需按访问内存方式读写
  - 方便共享磁盘文件

#### 3.2.8 虚拟存储器性能影响因素
- 缺页率
- 写回磁盘频率

#### 3.2.9 地址翻译（看完计组再来？）

