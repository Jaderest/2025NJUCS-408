# 第三章 内存管理

先抄框架，具体内容做完题再填充

## 目录
- [第三章 内存管理](#第三章-内存管理)
  - [目录](#目录)
  - [3.1 内存管理概念](#31-内存管理概念)
    - [3.1.1 内存管理的基本原理和要求](#311-内存管理的基本原理和要求)
      - [内存管理主要功能](#内存管理主要功能)
      - [基本原理](#基本原理)
    - [3.1.2 连续分配管理方式](#312-连续分配管理方式)
      - [连续分配方式](#连续分配方式)
      - [动态分区分配（仍为连续分配方式）](#动态分区分配仍为连续分配方式)
    - [非连续分配方式](#非连续分配方式)
      - [3.1.3 基本分页存储管理](#313-基本分页存储管理)
      - [3.1.4 基本分段存储管理](#314-基本分段存储管理)
      - [3.1.5 段页式存储管理](#315-段页式存储管理)

## 3.1 内存管理概念

### 3.1.1 内存管理的基本原理和要求

#### 内存管理主要功能
- **内存空间的分配和回收**：记录空闲空间、分配情况、回收空间
- **地址转换**：vaddr -> paddr
- **内存扩充**：虚拟存储技术从逻辑上扩充内存
- **内存共享**：多个进程共享同一块内存空间，需支持堆内存共享区域的受控访问
- **存储保护**：互不干扰

#### 基本原理
1. 逻辑地址和物理地址
2. 程序链接与装入
  - 三个工作阶段
    - 编译：源代码 -> 若干目标模块
    - 链接：一组目标模块 + 库函数 -> 完整的装入模块
    - 装入：装入模块 装入 物理内存
  - 装入方式
    - 绝对装入
      - 只适用于单道程序环境
      - 逻辑地址与实际内存地址完全相同
    - 可重定位装入（静态重定位）
      - 编译链接后装入模块始地址通常从0开始
      - 程序中指令和数据的地址都是相对始址的**逻辑地址**
      - **重定位**：**装入时**对目标程序中相对地址的修改过程
      - 地址转换在装入时一次完成
    - 动态运行时装入（动态重定位）
      - 装入程序 将 装入模块装入内存后，不立即将相对地址转换为绝对地址
      - 真正要执行时，才将相对地址转换为绝对地址
      - 需重定位寄存器
      - 优点：程序可分配到不连续存储区；
  - 链接方式
    - 静态链接
      - 几个目标模块装配成一个完整的装入模块，需解决两个问题：
        - TODO
    - 装入时动态链接
      - 优点：TODO
    - 运行时动态链接
3. 进程内存映像
  - 基本要素
    - 代码段
    - 数据段
    - PCB（Process Control Block，进程控制块）
    - 堆
    - 栈
4. 内存保护
  - 两种方法
    - CPU设置上、下限寄存器，存放用户进程在贮存中下限地址和上限地址
      - CPU访问一个地址时，与俩寄存器相比，判断有无越界
    - 重定位寄存器（基地址寄存器）+ 界地址寄存器（限长寄存器）
      - 重定位寄存器存放进程的起始地址——用来 vaddr 转换为 paddr
      - 界地址寄存器存放进程的**最大逻辑地址**——逻辑地址与它相比，大则越界，小再通过重定位寄存器转换为物理地址
      - 使用这俩寄存器必须使用特权指令
5. 内存共享
  - 可重入代码（纯代码）
6. 内存分配与回收

### 3.1.2 连续分配管理方式
*连续分配*方式：用户需要100MB内存空间，连续分配就在内存空间中位用户分配一块连续的100MB空间

#### 连续分配方式
1. 单一连续分配
2. 固定分区分配
3. 动态分区分配

#### 动态分区分配（仍为连续分配方式）
1. 基本原理
2. 基于顺序搜索的分配算法
3. 基于索引搜索的分配算法

### 非连续分配方式
非连续分配方式，根据分区大小是否固定分为
- 分页存储管理（根据是否将作业所有页面都装入内存才能运行分为）
  - 基本分页存储管理
  - 请求分页存储管理
- 分段存储管理

#### 3.1.3 基本分页存储管理
- 物理内存中：4KB分区，称为*页框、页帧或物理块*
- 进程逻辑地址空间也分为与块大小相等的若干区域，称为*页或页面*
1. 分页存储基本概念
  - 页面和页面大小
    - 逻辑地址空间中每个页面有编号，称为*页号*
    - 内存空间中每个页框也有编号，称为*页框号*（物理块号）
    - 页面大小，2的整数次幂
  - 地址结构
    - 页号P 12~31位 （最多2^20个页面）
    - 页内偏移量W 0~11位 （页大小为2^12字节，即4KB）
  - 页表
    - 每个进程一个页面映射表（页表）
    - 页表项：由页号和块号组成
    - 作用：实现页号到物理块号的地址映射
2. 基本地址变换机构
  - 基本概念
    - 地址变换机构的任务：逻辑地址->内存中物理地址
    - *地址变换*借助于页表实现
    - 页表寄存器（Page Table Register，PTR）
      - 存放页表的在内存中起始地址和页表长度M
      - 进程未执行时，页表始址放在本进程PCB中；被调度执行时，页表始址和页表长度装入PTR
  - 页面大小L，逻辑地址A到物理地址E的变换
    - 页号P = A / L, 页内偏移量W = A % L
    - 判断页号越界
      - 如果P > M，页号越界，越界中断
      - 如果P <= M，页号合法
    - 页表寄存器：页表始址F，页表长度M
    - 页表项地址 = F + P * 页表项长度，根据地址取出页表项中物理块号b（页框号）
    - 物理地址E = b * L + W
3. 具有快表的地址变换机构
  - 快表（Translation Lookaside Buffer，TLB），相联存储器，不在内存中，是一个高速缓存
  - 有快表的地址变换过程如下：
    - CPU给出逻辑地址，硬件进行地址转换，页表与快表中所有页号进行比较
    - 若匹配上，直接从快表中取出该页对应物理块号b，与页内偏移量拼接形成物理地址，**一次访存**
    - 若未匹配上，访问内存中的页表，与基本地址变换机构相同，取出物理块号b，形成物理地址并访存，同时将页号P和物理块号b存入快表，**两次访存**
4. 两级页表
  - 每个进程页表项数可达2^20个，2^20 * 4B / 4KB = 1K个页，还要求连续，明显不现实
  - 两种解决办法：
    - 对于页表所需内存空间，采用离散分配方式，用一张索引表来记录各个页表的存放位置，解决了页表占用连续内存空间的问题
    - 只将需要的部分页表项调入内存，其余的页表项仍驻留磁盘，需要时再调入磁盘（虚拟内存的思想）
      - 实际上就是为离散分配的页表再建立一张页表，称为*外层页表*（或*页目录*）
      - 逻辑地址空间的格式：
        - 一级页号或页目录号10位
        - 二级页号或页表号10位
        - 页内偏移12位
  - **外层页表寄存器**（页目录基址寄存器）：存放页目录始址
    - 页目录号作为页目录索引，找到对应页表的始址
    - 再用*二级页号*作为页表分页索引，找到对应的页表项
    - 页表项的物理块号和页内偏移拼接形成物理地址
    - 使用该物理地址访存，共进行了**三次访存**

#### 3.1.4 基本分段存储管理
分页通过*硬件机制*实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，满足方便编程、信息保护和共享、动态增长及动态链接等多方面需要
1. 分段
  - 分段系统将用户进程的逻辑地址划分大小不等的*段*
    - 用户进程由主程序段、两个子程序段、栈段和数据段组成
    - 于是进程划分5段，每段从0开始编址，并分配一段连续的地址空间（段内连续，段间不连续）
    - 进程的地址空间是二维的
  - 分段存储管理的逻辑地址
    - 段号S 31~16位
    - 段内偏移量W 15~0位
    - 一个进程最多有2^16个段，最大段长64KB
  - 在分段系统中，段号和段内偏移量必须由用户显示提供，高级语言中由编译器完成
2. 段表
  - 每个段对应一个*段表项*
    ```
      |段号|段长|本段在主存的始址|
    ```
  - 段表项连续存放，各段表项长度相同，因此段号可以隐含（直接用段号作为索引）
  - 若段表存放始址为M，K号段存放的地址为 M + K * 6(6Byte = 16bit段内偏移量（可全部用来表示段长） + 32bit物理内存)
3. 地址变换机构
  - 段表寄存器（Segment Table Register，STR）：存放段表的起始地址F和段表长度M
  - 地址变换过程：
    1. 逻辑地址A中取出前几位为段号S，后几位为段内偏移量W
    2. 判断段号是否越界，S >= M，产生越界中断
    3. 段表查询段表项，段号S对应段表项地址 = F + S * 段表项长度
    4. 取出段表项中段长C，若W >= C，产生越界中断
    5. 取出该段始址b，物理地址E = b + W
4. 分页分段对比
  - 都是非连续分配方式，都需要地址映射机构实现地址变换
  - 概念上完全不同：
    1. 页是信息的物理单位，分页是提高内存利用率，完全是系统的行为，对用户不可见；段时信息的逻辑单位，为了更好地满足用户需求，用户按照逻辑关系将程序划分为若干段，分段对用户可见
    2. 页大小固定，由系统决定；段长不固定，取决于用户编写程序
    3. 分页管理地址空间是一维的；段管理，每段长度不固定，无法通过除法得出段号，所以分段管理的地址空间是二维的
5. 段共享与保护
  - 共享：
    - 段共享：为了共享，只需要为段设置一个段表项即可。共享段表，表项记录共享段的段号、段长、内存始址、状态（存在）位、外村始址、共享进程计数count等
    - 页共享：若被共享的代码占N个页框，则**每个**进程的页表中都要建立N个页表项，指向被共享的N个页框
  - 保护：
    - 段保护两种方法：
      1. 存取控制保护
      2. 地址越绝保护：段表寄存器中段表长度 与 逻辑地址中段号比较；段表项中段长 和 逻辑地址段内偏移比较
    - 分页：
      - 仅需判断页号是否越界，页内偏移不可能越界（位数固定）

#### 3.1.5 段页式存储管理
进程地址空间分为若干逻辑段，每段由自己段号，将各个段分成若干大小固定的页
- 进程逻辑地址分为三部分：
  ```
    |段号S|页号P|页内偏移量W|
  ```
- 每个进程一个段表
  - 段表项：段号（连续所以隐含）、页表长度，页表始地址
- 每个段一张页表（**所以每个进程可能有多个**）
  - 页表项：页号（连续所以隐含）、物理块号
- 系统维护段表寄存器，指出进程段表始址和段表长度
  - **段表寄存器和页表寄存器作用：1. 寻址 2. 判断是否越界**